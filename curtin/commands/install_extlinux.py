# This file is part of curtin. See LICENSE file for copyright and license info.

"""This loosely follows the u-boot-update script in the u-boot-menu package"""

import io
import os

from curtin import config
from curtin import paths
from curtin import util
from curtin.log import LOG

EXTLINUX_DIR = '/boot/extlinux'


def build_content(bootcfg: config.BootCfg, target: str, fw_boot_dir: str,
                  root_spec: str):
    """Build the content of the extlinux.conf file

    For now this only supports x86, since it does not handle the 'fdt' option.
    Rather than add that, the plan is to use a FIT (Flat Image Tree) which can
    handle FDT selection automatically. This should avoid the complexity
    associated with fdt and fdtdir options.

    We assume that the boot directory is available as /boot in the target.

    :param: bootcfg: A boot-config dict
    :param: target: A string specifying the path to the chroot mountpoint.
    :param: fw_boot_dir: Firmware's view of the /boot directory; when there is
        a separate /boot partition, firmware will access that as the root
        directory of the filesystem, so '' should be passed here. When the boot
        directory is just a subdirectory of '/', then '/boot' should be passed
    :param: root_spec: Root device to pass to kernel
    """
    def get_entry(label, params, menu_label_append=''):
        return f'''\
label {label}
\tmenu label {menu_label} {version}{menu_label_append}
\tlinux {fw_boot_dir}/{kernel_path}
\tinitrd {fw_boot_dir}/{initrd_path}
\tappend {params}'''

    buf = io.StringIO()
    params = f'{root_spec} ro quiet'
    menu_label = 'Linux'

    # For the recovery option, remove 'quiet' and add 'single'
    without_quiet = filter(lambda word: word != 'quiet', params.split())
    rec_params = ' '.join(list(without_quiet) + ['single'])

    print(f'''\
## {EXTLINUX_DIR}/extlinux.conf
##
## IMPORTANT WARNING
##
## The configuration of this file is generated automatically.
## Do not edit this file manually, use: u-boot-update

default l0
menu title U-Boot menu
prompt 0
timeout 50''', file=buf)
    for seq, (kernel_path, full_initrd_path, version) in enumerate(
            paths.get_kernel_list(target)):
        LOG.debug('P: Writing config for %s...', kernel_path)
        initrd_path = os.path.basename(full_initrd_path)
        print(file=buf)
        if 'default' in bootcfg.alternatives:
            print(file=buf)
            print(get_entry(f'l{seq}', params), file=buf)

        if 'rescue' in bootcfg.alternatives:
            print(file=buf)
            print(get_entry(f'l{seq}r', rec_params, ' (rescue target)'),
                  file=buf)

    return buf.getvalue()


def install_extlinux(
        bootcfg: config.BootCfg,
        target: str,
        fw_boot_dir: str,
        root_spec: str,
        ):
    """Install extlinux to the target chroot.

    :param: bootcfg: A boot-config dict.
    :param: target: A string specifying the path to the chroot mountpoint.
    :param: fw_boot_dir: Firmware's view of the /boot directory
    :param: root_spec: Root device to pass to kernel
    """
    LOG.debug("P: Writing extlinux, fw_boot_dir '%s' root_spec '%s'...",
              fw_boot_dir, root_spec)
    content = build_content(bootcfg, target, fw_boot_dir, root_spec)
    extlinux_path = paths.target_path(target, '/boot/extlinux')
    util.ensure_dir(extlinux_path)
    with open(extlinux_path + '/extlinux.conf', 'w', encoding='utf-8') as outf:
        outf.write(content)
